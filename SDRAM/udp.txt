; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\SDRAM\udp.o --asm_dir=.\SDRAM\ --list_dir=.\SDRAM\ --depend=.\SDRAM\udp.d --cpu=ARM920T --apcs=interwork -O0 -I..\Common\Inc -I.\INC -I.\INC\tftp -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Samsung --omf_browse=.\SDRAM\udp.crf Source\tftp\udp.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  udp_init PROC
;;;11     
;;;12     int udp_init(void)
000000  e3a00000          MOV      r0,#0
;;;13     {
;;;14     	return 0;
;;;15     }
000004  e12fff1e          BX       lr
;;;16     
                          ENDP

                  udp_rcv_packet PROC
;;;17     int udp_rcv_packet(struct sk_buff *skb)
000008  e92d4070          PUSH     {r4-r6,lr}
;;;18     {
00000c  e1a04000          MOV      r4,r0
;;;19     	struct udphdr *udp_hdr = (struct udphdr *)(skb->data);
000010  e59455f0          LDR      r5,[r4,#0x5f0]
;;;20     
;;;21     	skb->len = ntohs(udp_hdr->len);
000014  e5d51005          LDRB     r1,[r5,#5]
000018  e5d52004          LDRB     r2,[r5,#4]
00001c  e1820401          ORR      r0,r2,r1,LSL #8
000020  ebfffffe          BL       ntohs
000024  e58405f4          STR      r0,[r4,#0x5f4]
;;;22     	skb_pull(skb, sizeof(struct udphdr));
000028  e3a01008          MOV      r1,#8
00002c  e1a00004          MOV      r0,r4
000030  ebfffffe          BL       skb_pull
;;;23     
;;;24     	if (ntohs(udp_hdr->dest) == TFTP)
000034  e5d51003          LDRB     r1,[r5,#3]
000038  e5d52002          LDRB     r2,[r5,#2]
00003c  e1820401          ORR      r0,r2,r1,LSL #8
000040  ebfffffe          BL       ntohs
000044  e3500045          CMP      r0,#0x45
000048  1a000001          BNE      |L1.84|
;;;25     	{
;;;26     		tftp_rcv_packet(skb);
00004c  e1a00004          MOV      r0,r4
000050  ebfffffe          BL       tftp_rcv_packet
                  |L1.84|
;;;27     	}
;;;28     
;;;29     	return 0;
000054  e3a00000          MOV      r0,#0
000058  e8bd4070          POP      {r4-r6,lr}
;;;30     }
00005c  e12fff1e          BX       lr
;;;31     
                          ENDP

                  udp_send PROC
;;;32     int udp_send(struct sk_buff *skb, unsigned long ip,
000060  e92d41f0          PUSH     {r4-r8,lr}
;;;33     	unsigned short source, unsigned short dest)
;;;34     {
000064  e1a07000          MOV      r7,r0
000068  e1a08001          MOV      r8,r1
00006c  e1a05002          MOV      r5,r2
000070  e1a06003          MOV      r6,r3
;;;35     	struct udphdr *udp_hdr;
;;;36     
;;;37     	udp_hdr = (struct udphdr *)skb_push(skb, sizeof(struct udphdr));
000074  e3a01008          MOV      r1,#8
000078  e1a00007          MOV      r0,r7
00007c  ebfffffe          BL       skb_push
000080  e1a04000          MOV      r4,r0
;;;38     	udp_hdr->source = htons(source);
000084  e1a00005          MOV      r0,r5
000088  ebfffffe          BL       htons
00008c  e5c40000          STRB     r0,[r4,#0]
000090  e1a00420          LSR      r0,r0,#8
000094  e5c40001          STRB     r0,[r4,#1]
;;;39     	udp_hdr->dest = htons(dest);
000098  e1a00006          MOV      r0,r6
00009c  ebfffffe          BL       htons
0000a0  e5c40002          STRB     r0,[r4,#2]
0000a4  e1a00420          LSR      r0,r0,#8
0000a8  e5c40003          STRB     r0,[r4,#3]
;;;40     	udp_hdr->len = htons(12+sizeof(struct timehdr));
0000ac  e3a00016          MOV      r0,#0x16
0000b0  ebfffffe          BL       htons
0000b4  e5c40004          STRB     r0,[r4,#4]
0000b8  e1a00420          LSR      r0,r0,#8
0000bc  e5c40005          STRB     r0,[r4,#5]
;;;41     	udp_hdr->check = 0;
0000c0  e3a00000          MOV      r0,#0
0000c4  e5c40006          STRB     r0,[r4,#6]
0000c8  e5c40007          STRB     r0,[r4,#7]
;;;42     
;;;43     	//uart_printf("udplen: %d\n",skb->len);
;;;44     	ip_send(skb, ip, UDP);
0000cc  e3a02011          MOV      r2,#0x11
0000d0  e1a01008          MOV      r1,r8
0000d4  e1a00007          MOV      r0,r7
0000d8  ebfffffe          BL       ip_send
;;;45     
;;;46     	return 0;
0000dc  e3a00000          MOV      r0,#0
0000e0  e8bd41f0          POP      {r4-r8,lr}
;;;47     }
0000e4  e12fff1e          BX       lr
;;;48     
                          ENDP

                  udp_skb_reserve PROC
;;;49     void udp_skb_reserve(struct sk_buff *skb)
0000e8  e92d4010          PUSH     {r4,lr}
;;;50     {
0000ec  e1a04000          MOV      r4,r0
;;;51     	ip_skb_reserve(skb);
0000f0  e1a00004          MOV      r0,r4
0000f4  ebfffffe          BL       ip_skb_reserve
;;;52     	skb_reserve(skb, sizeof(struct udphdr));
0000f8  e3a01008          MOV      r1,#8
0000fc  e1a00004          MOV      r0,r4
000100  ebfffffe          BL       skb_reserve
;;;53     }
000104  e8bd4010          POP      {r4,lr}
000108  e12fff1e          BX       lr
;;;54     
                          ENDP

                  udp_get_source_port PROC
;;;55     unsigned short udp_get_source_port(struct sk_buff *skb)
00010c  e92d4070          PUSH     {r4-r6,lr}
;;;56     {
000110  e1a04000          MOV      r4,r0
;;;57     	struct udphdr *udp_hdr;
;;;58     	
;;;59     	udp_hdr = (struct udphdr *)(skb->buf + ETH_HLEN + sizeof(struct iphdr));
000114  e2845024          ADD      r5,r4,#0x24
;;;60     	return ntohs(udp_hdr->source);
000118  e5d51001          LDRB     r1,[r5,#1]
00011c  e5d52000          LDRB     r2,[r5,#0]
000120  e1820401          ORR      r0,r2,r1,LSL #8
000124  ebfffffe          BL       ntohs
000128  e8bd4070          POP      {r4-r6,lr}
;;;61     }
00012c  e12fff1e          BX       lr
;;;62     
                          ENDP

