; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\SDRAM\udp.o --asm_dir=.\SDRAM\ --list_dir=.\SDRAM\ --depend=.\SDRAM\udp.d --cpu=ARM920T --apcs=interwork -O0 -I..\Common\Inc -I.\INC -I.\INC\tftp -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Samsung --omf_browse=.\SDRAM\udp.crf Source\tftp\udp.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  udp_init PROC
;;;10     
;;;11     int udp_init(void)
000000  e3a00000          MOV      r0,#0
;;;12     {
;;;13     	return 0;
;;;14     }
000004  e12fff1e          BX       lr
;;;15     
                          ENDP

                  udp_rcv_packet PROC
;;;16     int udp_rcv_packet(struct sk_buff *skb)
000008  e92d4070          PUSH     {r4-r6,lr}
;;;17     {
00000c  e1a04000          MOV      r4,r0
;;;18     	struct udphdr *udp_hdr = (struct udphdr *)(skb->data);
000010  e59455f0          LDR      r5,[r4,#0x5f0]
;;;19     
;;;20     	skb->len = ntohs(udp_hdr->len);
000014  e5d51005          LDRB     r1,[r5,#5]
000018  e5d52004          LDRB     r2,[r5,#4]
00001c  e1820401          ORR      r0,r2,r1,LSL #8
000020  ebfffffe          BL       ntohs
000024  e58405f4          STR      r0,[r4,#0x5f4]
;;;21     	skb_pull(skb, sizeof(struct udphdr));
000028  e3a01008          MOV      r1,#8
00002c  e1a00004          MOV      r0,r4
000030  ebfffffe          BL       skb_pull
;;;22     
;;;23     	if (ntohs(udp_hdr->dest) == TFTP)
000034  e5d51003          LDRB     r1,[r5,#3]
000038  e5d52002          LDRB     r2,[r5,#2]
00003c  e1820401          ORR      r0,r2,r1,LSL #8
000040  ebfffffe          BL       ntohs
000044  e3500045          CMP      r0,#0x45
000048  1a000001          BNE      |L1.84|
;;;24     	{
;;;25     		tftp_rcv_packet(skb);
00004c  e1a00004          MOV      r0,r4
000050  ebfffffe          BL       tftp_rcv_packet
                  |L1.84|
;;;26     	}
;;;27     
;;;28     	return 0;
000054  e3a00000          MOV      r0,#0
000058  e8bd4070          POP      {r4-r6,lr}
;;;29     }
00005c  e12fff1e          BX       lr
;;;30     
                          ENDP

                  udp_send PROC
;;;31     int udp_send(struct sk_buff *skb, unsigned long ip,
000060  e92d41f0          PUSH     {r4-r8,lr}
;;;32     	unsigned short source, unsigned short dest)
;;;33     {
000064  e1a05000          MOV      r5,r0
000068  e1a08001          MOV      r8,r1
00006c  e1a06002          MOV      r6,r2
000070  e1a07003          MOV      r7,r3
;;;34     	struct udphdr *udp_hdr;
;;;35     
;;;36     	udp_hdr = (struct udphdr *)skb_push(skb, sizeof(struct udphdr));
000074  e3a01008          MOV      r1,#8
000078  e1a00005          MOV      r0,r5
00007c  ebfffffe          BL       skb_push
000080  e1a04000          MOV      r4,r0
;;;37     	udp_hdr->source = htons(source);
000084  e1a00006          MOV      r0,r6
000088  ebfffffe          BL       htons
00008c  e5c40000          STRB     r0,[r4,#0]
000090  e1a00420          LSR      r0,r0,#8
000094  e5c40001          STRB     r0,[r4,#1]
;;;38     	udp_hdr->dest = htons(dest);
000098  e1a00007          MOV      r0,r7
00009c  ebfffffe          BL       htons
0000a0  e5c40002          STRB     r0,[r4,#2]
0000a4  e1a00420          LSR      r0,r0,#8
0000a8  e5c40003          STRB     r0,[r4,#3]
;;;39     	udp_hdr->len = htons(30);
0000ac  e3a0001e          MOV      r0,#0x1e
0000b0  ebfffffe          BL       htons
0000b4  e5c40004          STRB     r0,[r4,#4]
0000b8  e1a00420          LSR      r0,r0,#8
0000bc  e5c40005          STRB     r0,[r4,#5]
;;;40     	udp_hdr->check = 0;
0000c0  e3a00000          MOV      r0,#0
0000c4  e5c40006          STRB     r0,[r4,#6]
0000c8  e5c40007          STRB     r0,[r4,#7]
;;;41     
;;;42     	uart_printf("udplen: %d\n",skb->len);
0000cc  e28f0068          ADR      r0,|L1.316|
0000d0  e59515f4          LDR      r1,[r5,#0x5f4]
0000d4  ebfffffe          BL       uart_printf
;;;43     	ip_send(skb, ip, UDP);
0000d8  e3a02011          MOV      r2,#0x11
0000dc  e1a01008          MOV      r1,r8
0000e0  e1a00005          MOV      r0,r5
0000e4  ebfffffe          BL       ip_send
;;;44     
;;;45     	return 0;
0000e8  e3a00000          MOV      r0,#0
0000ec  e8bd41f0          POP      {r4-r8,lr}
;;;46     }
0000f0  e12fff1e          BX       lr
;;;47     
                          ENDP

                  udp_skb_reserve PROC
;;;48     void udp_skb_reserve(struct sk_buff *skb)
0000f4  e92d4010          PUSH     {r4,lr}
;;;49     {
0000f8  e1a04000          MOV      r4,r0
;;;50     	ip_skb_reserve(skb);
0000fc  e1a00004          MOV      r0,r4
000100  ebfffffe          BL       ip_skb_reserve
;;;51     	skb_reserve(skb, sizeof(struct udphdr));
000104  e3a01008          MOV      r1,#8
000108  e1a00004          MOV      r0,r4
00010c  ebfffffe          BL       skb_reserve
;;;52     }
000110  e8bd4010          POP      {r4,lr}
000114  e12fff1e          BX       lr
;;;53     
                          ENDP

                  udp_get_source_port PROC
;;;54     unsigned short udp_get_source_port(struct sk_buff *skb)
000118  e92d4070          PUSH     {r4-r6,lr}
;;;55     {
00011c  e1a04000          MOV      r4,r0
;;;56     	struct udphdr *udp_hdr;
;;;57     	
;;;58     	udp_hdr = (struct udphdr *)(skb->buf + ETH_HLEN + sizeof(struct iphdr));
000120  e2845024          ADD      r5,r4,#0x24
;;;59     	return ntohs(udp_hdr->source);
000124  e5d51001          LDRB     r1,[r5,#1]
000128  e5d52000          LDRB     r2,[r5,#0]
00012c  e1820401          ORR      r0,r2,r1,LSL #8
000130  ebfffffe          BL       ntohs
000134  e8bd4070          POP      {r4-r6,lr}
;;;60     }
000138  e12fff1e          BX       lr
;;;61     
                          ENDP

                  |L1.316|
00013c  7564706c          DCB      "udplen: %d\n",0
000140  656e3a20
000144  25640a00
